#########Rabbits and Recurrence Relations########################
#########http://rosalind.info/problems/fib/######################

Wascally Wabbitsclick

In 1202, Leonardo of Pisa (commonly known as Fibonacci) considered a mathematical exercise regarding the reproduction of a population of rabbits. He made the following simplifying assumptions about the population:

The population begins in the first month with a pair of newborn rabbits.
Rabbits reach reproductive age after one month.
In any given month, every rabbit of reproductive age mates with another rabbit of reproductive age.
Exactly one month after two rabbits mate, they produce one male and one female rabbit.
Rabbits never die or stop reproducing.
Fibonacci's exercise was to calculate how many pairs of rabbits would remain in one year. We can see that in the second month, the first pair of rabbits reach reproductive age and mate. In the third month, another pair of rabbits is born, and we have two rabbit pairs; our first pair of rabbits mates again. In the fourth month, another pair of rabbits is born to the original pair, while the second pair reach maturity and mate (with three total pairs). The dynamics of the rabbit population are illustrated in Figure 1. After a year, the rabbit population boasts 144 pairs.

Although Fibonacci's assumption of the rabbits' immortality may seem a bit farfetched, his model was not unrealistic for reproduction in a predator-free environment: European rabbits were introduced to Australia in the mid 19th Century, a place with no real indigenous predators for them. Within 50 years, the rabbits had already eradicated many plant species across the continent, leading to irreversible changes in the Australian ecosystem and turning much of its grasslands into eroded, practically uninhabitable parts of the modern Outback (see Figure 2). In this problem, we will use the simple idea of counting rabbits to introduce a new computational topic, which involves building up large solutions from smaller ones.


Problem

A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat. Sequences can be finite or infinite. Two examples are the finite sequence (œÄ,‚àí2‚Äæ‚Äæ‚àö,0,œÄ) and the infinite sequence of odd numbers (1,3,5,7,9,‚Ä¶). We use the notation an to represent the n-th term of a sequence.

A recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms. In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior. As a result, if Fn represents the number of rabbit pairs alive after the n-th month, then we obtain the Fibonacci sequence having terms Fn that are defined by the recurrence relation Fn=Fn‚àí1+Fn‚àí2 (with F1=F2=1 to initiate the sequence). Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago.

When finding the n-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of n. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.

Given: Positive integers n‚â§40 and k‚â§5.

Return: The total number of rabbit pairs that will be present after n months if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of k rabbit pairs (instead of only 1 pair).



######Consensus and Profile#########################################
######http://rosalind.info/problems/cons/##########################

Finding a Most Likely Common Ancestor

In ‚ÄúCounting Point Mutations‚Äù, we calculated the minimum number of symbol mismatches between two strings of equal length to model the problem of finding the minimum number of point mutations occurring on the evolutionary path between two homologous strands of DNA. If we instead have several homologous strands that we wish to analyze simultaneously, then the natural problem is to find an average-case strand to represent the most likely common ancestor of the given strands.

Problem

A matrix is a rectangular table of values divided into rows and columns. An m√ón matrix has m rows and n columns. Given a matrix A, we write Ai,j to indicate the value found at the intersection of row i and column j.

Say that we have a collection of DNA strings, all having the same length n. Their profile matrix is a 4√ón matrix P in which P1,j represents the number of times that 'A' occurs in the jth position of one of the strings, P2,j represents the number of times that C occurs in the jth position, and so on (see below).

A consensus string c is a string of length n formed from our collection by taking the most common symbol at each position; the jth symbol of c therefore corresponds to the symbol having the maximum value in the j-th column of the profile matrix. Of course, there may be more than one most common symbol, leading to multiple possible consensus strings.

		A T C C A G C T
		G G G C A A C T
		A T G G A T C T
DNA Strings	A A G C A A C C
		T T G G A A C T
		A T G C C A T T
		A T G G C A C T


		A   5 1 0 0 5 5 0 0
Profile		C   0 0 1 4 2 0 6 1
		G   1 1 6 3 0 1 0 0
		T   1 5 0 0 0 1 1 6


Consensus	A T G C A A C T


Given: A collection of at most 10 DNA strings of equal length (at most 1 kbp) in FASTA format.

Return: A consensus string and profile matrix for the collection. (If several possible consensus strings exist, then you may return any one of them.)


#############Mortal Fibonacci Rabbits#############################
#############http://rosalind.info/problems/fibd/###################

Problem

Figure 4. A figure illustrating the propagation of Fibonacci's rabbits if they die after three months.
Recall the definition of the Fibonacci numbers from ‚ÄúRabbits and Recurrence Relations‚Äù, which followed the recurrence relation Fn=Fn‚àí1+Fn‚àí2 and assumed that each pair of rabbits reaches maturity in one month and produces a single pair of offspring (one male, one female) each subsequent month.

Our aim is to somehow modify this recurrence relation to achieve a dynamic programming solution in the case that all rabbits die out after a fixed number of months. See Figure 4 for a depiction of a rabbit tree in which rabbits live for three months (meaning that they reproduce only twice before dying).

Given: Positive integers n‚â§100 and m‚â§20.

Return: The total number of pairs of rabbits that will remain after the n-th month if all rabbits live for m months.


###########Overlap Graphs#########################################
###########http://rosalind.info/problems/grph/####################


A Brief Introduction to Graph Theory

Networks arise everywhere in the practical world, especially in biology. Networks are prevalent in popular applications such as modeling the spread of disease, but the extent of network applications spreads far beyond popular science. Our first question asks how to computationally model a network without actually needing to render a picture of the network.

First, some terminology: graph is the technical term for a network; a graph is made up of hubs called nodes (or vertices), pairs of which are connected via segments/curves called edges. If an edge connects nodes v and w, then it is denoted by v,w (or equivalently w,v).

an edge v,w is incident to nodes v and w; we say that v and w are adjacent to each other;
the degree of v is the number of edges incident to it;
a walk is an ordered collection of edges for which the ending node of one edge is the starting node of the next (e.g., {v1,v2}, {v2,v3}, {v3,v4}, etc.);
a path is a walk in which every node appears in at most two edges;
path length is the number of edges in the path;
a cycle is a path whose final node is equal to its first node (so that every node is incident to exactly two edges in the cycle); and
the distance between two vertices is the length of the shortest path connecting them.
Graph theory is the abstract mathematical study of graphs and their properties.


Problem

A graph whose nodes have all been labeled can be represented by an adjacency list, in which each row of the list contains the two node labels corresponding to a unique edge.

A directed graph (or digraph) is a graph containing directed edges, each of which has an orientation. That is, a directed edge is represented by an arrow instead of a line segment; the starting and ending nodes of an edge form its tail and head, respectively. The directed edge with tail v and head w is represented by (v,w) (but not by (w,v)). A directed loop is a directed edge of the form (v,v).

For a collection of strings and a positive integer k, the overlap graph for the strings is a directed graph Ok in which each string is represented by a node, and string s is connected to string t with a directed edge when there is a length k suffix of s that matches a length k prefix of t, as long as s‚â†t; we demand s‚â†t to prevent directed loops in the overlap graph (although directed cycles may be present).

Given: A collection of DNA strings in FASTA format having total length at most 10 kbp.

Return: The adjacency list corresponding to O3. You may return edges in any order.


#################Calculating Expected Offspring#########################
#################http://rosalind.info/problems/iev/#####################


Problem

For a random variable X taking integer values between 1 and n, the expected value of X is E(X)=‚àënk=1k√óPr(X=k). The expected value offers us a way of taking the long-term average of a random variable over a large number of trials.

As a motivating example, let X be the number on a six-sided die. Over a large number of rolls, we should expect to obtain an average of 3.5 on the die (even though it's not possible to roll a 3.5). The formula for expected value confirms that E(X)=‚àë6k=1k√óPr(X=k)=3.5.

More generally, a random variable for which every one of a number of equally spaced outcomes has the same probability is called a uniform random variable (in the die example, this "equal spacing" is equal to 1). We can generalize our die example to find that if X is a uniform random variable with minimum possible value a and maximum possible value b, then E(X)=a+b2. You may also wish to verify that for the dice example, if Y is the random variable associated with the outcome of a second die roll, then E(X+Y)=7.

Given: Six positive integers, each of which does not exceed 20,000. The integers correspond to the number of couples in a population possessing each genotype pairing for a given factor. In order, the six given integers represent the number of couples having the following genotypes:

AA-AA
AA-Aa
AA-aa
Aa-Aa
Aa-aa
aa-aa


Return: The expected number of offspring displaying the dominant phenotype in the next generation, under the assumption that every couple has exactly two offspring.


###################Finding a Shared Motif##################################
###################http://rosalind.info/problems/lcsm/#####################


Searching Through the Haystack

In ‚ÄúFinding a Motif in DNA‚Äù, we searched a given genetic string for a motif; however, this problem assumed that we know the motif in advance. In practice, biologists often do not know exactly what they are looking for. Rather, they must hunt through several different genomes at the same time to identify regions of similarity that may indicate genes shared by different organisms or species.

The simplest such region of similarity is a motif occurring without mutation in every one of a collection of genetic strings taken from a database; such a motif corresponds to a substring shared by all the strings. We want to search for long shared substrings, as a longer motif will likely indicate a greater shared function.


Problem

A common substring of a collection of strings is a substring of every member of the collection. We say that a common substring is a longest common substring if there does not exist a longer common substring. For example, "CG" is a common substring of "ACGTACGT" and "AACCGGTATA", but it is not as long as possible; in this case, "GTA" is a longest common substring of "ACGTACGT" and "AACCGTATA".

Note that the longest common substring is not necessarily unique; for a simple example, "AA" and "CC" are both longest common substrings of "AACC" and "CCAA".

Given: A collection of k (k‚â§100) DNA strings of length at most 1 kbp each in FASTA format.

Return: A longest common substring of the collection. (If multiple solutions exist, you may return any single solution.)



###################Independent Alleles#####################################
###################http://rosalind.info/problems/lia/######################

Problem


Figure 2. The probability of each outcome for the sum of the values on two rolled dice (black and white), broken down depending on the number of pips showing on each die. You can verify that 18 of the 36 equally probable possibilities result in an odd sum.
Two events A and B are independent if Pr(A and B) is equal to Pr(A)√óPr(B). In other words, the events do not influence each other, so that we may simply calculate each of the individual probabilities separately and then multiply.

More generally, random variables X and Y are independent if whenever A and B are respective events for X and Y, A and B are independent (i.e., Pr(A and B)=Pr(A)√óPr(B)).

As an example of how helpful independence can be for calculating probabilities, let X and Y represent the numbers showing on two six-sided dice. Intuitively, the number of pips showing on one die should not affect the number showing on the other die. If we want to find the probability that X+Y is odd, then we don't need to draw a tree diagram and consider all possibilities. We simply first note that for X+Y to be odd, either X is even and Y is odd or X is odd and Y is even. In terms of probability, Pr(X+Y is odd)=Pr(X is even and Y is odd)+Pr(X is odd and Y is even). Using independence, this becomes [Pr(X is even)√óPr(Y is odd)]+[Pr(X is odd)√óPr(Y is even)], or (12)2+(12)2=12. You can verify this result in Figure 2, which shows all 36 outcomes for rolling two dice.

Given: Two positive integers k (k‚â§7) and N (N‚â§2k). In this problem, we begin with Tom, who in the 0th generation has genotype Aa Bb. Tom has two children in the 1st generation, each of whom has two children, and so on. Each organism always mates with an organism having genotype Aa Bb.

Return: The probability that at least N Aa Bb organisms will belong to the k-th generation of Tom's family tree (don't count the Aa Bb mates at each level). Assume that Mendel's second law holds for the factors.


####################Inferring mRNA from Protein#############################
####################http://rosalind.info/problems/mrna/####################


Problem

For positive integers a and n, a modulo n (written amodn in shorthand) is the remainder when a is divided by n. For example, 29mod11=7 because 29=11√ó2+7.

Modular arithmetic is the study of addition, subtraction, multiplication, and division with respect to the modulo operation. We say that a and b are congruent modulo n if amodn=bmodn; in this case, we use the notation a‚â°bmodn.

Two useful facts in modular arithmetic are that if a‚â°bmodn and c‚â°dmodn, then a+c‚â°b+dmodn and a√óc‚â°b√ódmodn. To check your understanding of these rules, you may wish to verify these relationships for a=29, b=73, c=10, d=32, and n=11.

As you will see in this exercise, some Rosalind problems will ask for a (very large) integer solution modulo a smaller number to avoid the computational pitfalls that arise with storing such large numbers.

Given: A protein string of length at most 1000 aa.

Return: The total number of different RNA strings from which the protein could have been translated, modulo 1,000,000. (Don't neglect the importance of the stop codon in protein translation.)



####################Enumerating Gene Orders################################
####################http://rosalind.info/problems/perm/####################

Problem

A permutation of length n is an ordering of the positive integers {1,2,‚Ä¶,n}. For example, œÄ=(5,3,2,1,4) is a permutation of length 5.

Given: A positive integer n‚â§7.

Return: The total number of permutations of length n, followed by a list of all such permutations (in any order).


####################Locating Restriction Sites###########################
####################http://rosalind.info/problems/revp/##################

Problem

A DNA string is a reverse palindrome if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See Figure 2.

Given: A DNA string of length at most 1 kbp in FASTA format.

Return: The position and length of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order.


###################RNA Splicing##########################################
###################http://rosalind.info/problems/splc/###################

Problem

After identifying the exons and introns of an RNA string, we only need to delete the introns and concatenate the exons to form a new string ready for translation.

Given: A DNA string s (of length at most 1 kbp) and a collection of substrings of s acting as introns. All strings are given in FASTA format.

Return: A protein string resulting from transcribing and translating the exons of s. (Note: Only one solution will exist for the dataset provided.)



###################Enumerating k-mers Lexicographically#####################
###################http://rosalind.info/problems/lexf/######################


Problem

Assume that an alphabet ùíú has a predetermined order; that is, we write the alphabet as a permutation ùíú=(a1,a2,‚Ä¶,ak), where a1<a2<‚ãØ<ak. For instance, the English alphabet is organized as (A,B,‚Ä¶,Z).

Given two strings s and t having the same length n, we say that s precedes t in the lexicographic order (and write s<Lext) if the first symbol s[j] that doesn't match t[j] satisfies sj<tj in ùíú.

Given: A collection of at most 10 symbols defining an ordered alphabet, and a positive integer n (n‚â§10).

Return: All strings of length n that can be formed from the alphabet, ordered lexicographically.



#################Genome Assembly as Shortest Superstring################## 
#################http://rosalind.info/problems/long/######################

Problem

For a collection of strings, a larger string containing every one of the smaller strings as a substring is called a superstring.

By the assumption of parsimony, a shortest possible superstring over a collection of reads serves as a candidate chromosome.

Given: At most 50 DNA strings whose length does not exceed 1 kbp in FASTA format (which represent reads deriving from the same strand of a single linear chromosome).

The dataset is guaranteed to satisfy the following condition: there exists a unique way to reconstruct the entire chromosome from these reads by gluing together pairs of reads that overlap by more than half their length.

Return: A shortest superstring containing all the given strings (thus corresponding to a reconstructed chromosome).



################Perfect Matchings and RNA Secondary Structures############
################http://rosalind.info/problems/pmch/#######################

Problem

A matching in a graph G is a collection of edges of G for which no node belongs to more than one edge in the collection. See Figure 2 for examples of matchings. If G contains an even number of nodes (say 2n), then a matching on G is perfect if it contains n edges, which is clearly the maximum possible. An example of a graph containing a perfect matching is shown in Figure 3.

First, let Kn denote the complete graph on 2n labeled nodes, in which every node is connected to every other node with an edge, and let pn denote the total number of perfect matchings in Kn. For a given node x, there are 2n‚àí1 ways to join x to the other nodes in the graph, after which point we must form a perfect matching on the remaining 2n‚àí2 nodes. This reasoning provides us with the recurrence relation pn=(2n‚àí1)‚ãÖpn‚àí1; using the fact that p1 is 1, this recurrence relation implies the closed equation pn=(2n‚àí1)(2n‚àí3)(2n‚àí5)‚ãØ(3)(1).

Given an RNA string s=s1‚Ä¶sn, a bonding graph for s is formed as follows. First, assign each symbol of s to a node, and arrange these nodes in order around a circle, connecting them with edges called adjacency edges. Second, form all possible edges {A, U} and {C, G}, called basepair edges; we will represent basepair edges with dashed edges, as illustrated by the bonding graph in Figure 4.

Note that a matching contained in the basepair edges will represent one possibility for base pairing interactions in s, as shown in Figure 5. For such a matching to exist, s must have the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'.

Given: An RNA string s of length at most 80 bp having the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'.

Return: The total possible number of perfect matchings of basepair edges in the bonding graph of s.



#####################Enumerating Oriented Gene Orderings################################
#####################http://rosalind.info/problems/sign/################################

Problem

A signed permutation of length n is some ordering of the positive integers {1,2,‚Ä¶,n} in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example, œÄ=(5,‚àí3,‚àí2,1,4) is a signed permutation of length 5.

Given: A positive integer n‚â§6.

Return: The total number of signed permutations of length n, followed by a list of all such permutations (you may list the signed permutations in any order).



#####################Transitions and Transversions#####################################
#####################http://rosalind.info/problems/tran/##############################

Problem

For DNA strings s1 and s2 having the same length, their transition/transversion ratio R(s1,s2) is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatched corresponding symbols as when calculating Hamming distance (see ‚ÄúCounting Point Mutations‚Äù).

Given: Two DNA strings s1 and s2 of equal length (at most 1 kbp).

Return: The transition/transversion ratio R(s1,s2).


######################Completing a Tree#################################################
######################http://rosalind.info/problems/tree/###############################

Problem

Figure 2. A labeled tree with 6 vertices and 5 edges.
An undirected graph is connected if there is a path connecting any two nodes. A tree is a connected (undirected) graph containing no cycles; this definition forces the tree to have a branching structure organized around a central core of nodes, just like its living counterpart. See Figure 2.

We have already grown familiar with trees in ‚ÄúMendel's First Law‚Äù, where we introduced the probability tree diagram to visualize the outcomes of a random variable.

In the creation of a phylogeny, taxa are encoded by the tree's leaves, or nodes having degree 1. A node of a tree having degree larger than 1 is called an internal node.

Given: A positive integer n (n‚â§1000) and an adjacency list corresponding to a graph on n nodes that contains no cycles.

Return: The minimum number of edges that can be added to the graph to produce a tree.


###################Catalan Numbers and RNA Secondary Structures########################
###################http://rosalind.info/problems/cat/###################################
The Human Knotclick

You may have had the misfortune to participate in a team-building event that featured the "human knot," in which everyone joins hands with two other people, and the group must undo the giant knot of arms without letting go (see Figure 1).

Let's consider a simplified version of the human knot. Say that we have an even number of people at a party who are standing in a circle, and they pair off and shake hands at the same time. One combinatorial question at hand asks us to count the total number of ways that the guests can shake hands without any two pairs interfering with each other by crossing arms.

This silly little counting problem is actually an excellent analogy for RNA folding. In practice, base pairing can occur anywhere along the RNA molecule, but the secondary structure of RNA often forbids base pairs crossing over each other, which forms a structure called a pseudoknot (see Figure 2)). Pseudoknots are not technically knots, but they nevertheless cause RNA to fold over itself.

Forbidding pseudoknots offers an interesting wrinkle to the problem of counting potential RNA secondary structures that we started working with in ‚ÄúPerfect Matchings and RNA Secondary Structures‚Äù, in which every possible nucleotide of a strand of RNA must base pair with another nucleotide.

Problem

A matching in a graph is noncrossing if none of its edges cross each other. If we assume that the n nodes of this graph are arranged around a circle, and if we label these nodes with positive integers between 1 and n, then a matching is noncrossing as long as there are not edges {i,j} and {k,l} such that i<k<j<l.

A noncrossing matching of basepair edges in the bonding graph corresponding to an RNA string will correspond to a possible secondary structure of the underlying RNA strand that lacks pseudoknots, as shown in Figure 3.

In this problem, we will consider counting noncrossing perfect matchings of basepair edges. As a motivating example of how to count noncrossing perfect matchings, let cn denote the number of noncrossing perfect matchings in the complete graph K2n. After setting c0=1, we can see that c1 should equal 1 as well. As for the case of a general n, say that the nodes of K2n are labeled with the positive integers from 1 to 2n. We can join node 1 to any of the remaining 2n‚àí1 nodes; yet once we have chosen this node (say m), we cannot add another edge to the matching that crosses the edge {1,m}. As a result, we must match all the edges on one side of {1,m} to each other. This requirement forces m to be even, so that we can write m=2k for some positive integer k.

There are 2k‚àí2 nodes on one side of {1,m} and 2n‚àí2k nodes on the other side of {1,m}, so that in turn there will be ck‚àí1‚ãÖcn‚àík different ways of forming a perfect matching on the remaining nodes of K2n. If we let m vary over all possible n‚àí1 choices of even numbers between 1 and 2n, then we obtain the recurrence relation cn=‚àënk=1ck‚àí1‚ãÖcn‚àík. The resulting numbers cn counting noncrossing perfect matchings in K2n are called the Catalan numbers, and they appear in a huge number of other settings. See Figure 4 for an illustration counting the first four Catalan numbers.

Given: An RNA string s having the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'. The length of the string is at most 300 bp.

Return: The total number of noncrossing perfect matchings of basepair edges in the bonding graph of s, modulo 1,000,000.


########################Error Correction in Reads ######################################
########################http://rosalind.info/problems/corr/#############################

Problem

As is the case with point mutations, the most common type of sequencing error occurs when a single nucleotide from a read is interpreted incorrectly.

Given: A collection of up to 1000 reads of equal length (at most 50 bp) in FASTA format. Some of these reads were generated with a single-nucleotide error. For each read s in the dataset, one of the following applies:

s was correctly sequenced and appears in the dataset at least twice (possibly as a reverse complement);
s is incorrect, it appears in the dataset exactly once, and its Hamming distance is 1 with respect to exactly one correct read in the dataset (or its reverse complement).
Return: A list of all corrections in the form "[old read]->[new read]". (Each correction must be a single symbol substitution, and you may return the corrections in any order.)

#######################Counting Phylogenetic Ancestors#################################
#######################http://rosalind.info/problems/inod/#############################

Culling the Forestclick to collapse

In ‚ÄúCompleting a Tree‚Äù, we introduced the tree for the purposes of constructing phylogenies. Yet the definition of tree as a connected graph with no cycles produces a huge class of different graphs, from simple paths and star-like graphs to more familiar arboreal structures (see Figure 1). Which of these graphs are appropriate for phylogenetic study?

Modern evolutionary theory (beginning with Darwin) indicates that the only way a new species can be created is if it splits off from an existing species after a population is isolated for an extended period of time. This model of species evolution implies a very specific type of phylogeny, in which internal nodes represent branching points of evolution where an ancestor species either evolved into a new species or split into two new species: therefore, one edge of this internal node therefore connects the node to its most recent ancestor, whereas one or two new edges connect it to its immediate descendants. This framework offers a much clearer notion of how to characterize phylogenies.

Problem

A binary tree is a tree in which each node has degree equal to at most 3. The binary tree will be our main tool in the construction of phylogenies.

A rooted tree is a tree in which one node (the root) is set aside to serve as the pinnacle of the tree. A standard graph theory exercise is to verify that for any two nodes of a tree, exactly one path connects the nodes. In a rooted tree, every node v will therefore have a single parent, or the unique node w such that the path from v to the root contains {v,w}. Any other node x adjacent to v is called a child of v because v must be the parent of x; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its leaves, and as a result, we may often view a rooted tree with undirected edges as a directed graph in which each edge is oriented from parent to child. We should already be familiar with this idea; it's how the Rosalind problem tree works!

Even though a binary tree can include nodes having degree 2, an unrooted binary tree is defined more specifically: all internal nodes have degree 3. In turn, a rooted binary tree is such that only the root has degree 2 (all other internal nodes have degree 3).

Given: A positive integer n (3‚â§n‚â§10000).

Return: The number of internal nodes of any unrooted binary tree having n leaves.

#######################k-Mer Composition##############################################
#######################http://rosalind.info/problems/kmer/############################

Generalizing GC-Content

A length k substring of a genetic string is commonly called a k-mer. A genetic string of length n can be seen as composed of n‚àík+1 overlapping k-mers. The k-mer composition of a genetic string encodes the number of times that each possible k-mer occurs in the string. See Figure 1. The 1-mer composition is a generalization of the GC-content of a strand of DNA, and the 2-mer, 3-mer, and 4-mer compositions of a DNA string are also commonly known as its di-nucleotide, tri-nucleotide, and tetra-nucleotide compositions.

The biological significance of k-mer composition is manyfold. GC-content is helpful not only in helping to identify a piece of unknown DNA (see ‚ÄúComputing GC Content‚Äù), but also because a genomic region having high GC-content compared to the rest of the genome signals that it may belong to an exon. Analyzing k-mer composition is vital to fragment assembly as well.

In ‚ÄúComputing GC Content‚Äù, we also drew an analogy between analyzing the frequency of characters and identifying the underlying language. For larger values of k, the k-mer composition offers a more robust fingerprint of a string's identity because it offers an analysis on the scale of substrings (i.e., words) instead of that of single symbols. As a basis of comparison, in language analysis, the k-mer composition of a text can be used not only to pin down the language, but also often the author.

Problem

For a fixed positive integer k, order all possible k-mers taken from an underlying alphabet lexicographically.

Then the k-mer composition of a string s can be represented by an array A for which A[m] denotes the number of times that the mth k-mer (with respect to the lexicographic order) appears in s.

Given: A DNA string s in FASTA format (having length at most 100 kbp).

Return: The 4-mer composition of s.


########################Speeding Up Motif Finding#######################################
########################http://rosalind.info/problems/kmp/##############################

Shortening the Motif Search

In ‚ÄúFinding a Motif in DNA‚Äù, we discussed the problem of searching a genome for a known motif. Because of the large scale of eukaryotic genomes, we need to accomplish this computational task as efficiently as possible.

The standard method for locating one string t as a substring of another string s (and perhaps one you implemented in ‚ÄúFinding a Motif in DNA‚Äù) is to move a sliding window across the larger string, at each step starting at s[k] and matching subsequent symbols of t to symbols of s. After we have located a match or mismatch, we then shift the window backwards to begin searching at s[k+1].

The potential weakness of this method is as follows: say we have matched 100 symbols of t to s before reaching a mismatch. The window-sliding method would then move back 99 symbols of s and start comparing t to s; can we avoid some of this sliding?

For example, say that we are looking for t=ACGTACGT in s=TAGGTACGTACGGCATCACG. From s[6] to s[12], we have matched seven symbols of t, and yet s[13] = G produces a mismatch with t[8] = T. We don't need to go all the way back to s[7] and start matching with t because s[7]=C, s[8]=G, and s[9]=T are all different from t[1]=A. What about s[10]? Because t[1:4]=t[5:8]=ACGT, the previous mismatch of s[13]=G and t[8]=T guarantees the same mismatch with s[13] and t[4]. Following this analysis, we may advance directly to s[14] and continue sliding our window, without ever having to move it backward.

This method can be generalized to form the framework behind the Knuth-Morris-Pratt algorithm (KMP), which was published in 1977 and offers an efficiency boost for determining whether a given motif can be located within a larger string.

Problem

A prefix of a length n string s is a substring s[1:j]; a suffix of s is a substring s[k:n].

The failure array of s is an array P of length n for which P[k] is the length of the longest substring s[j:k] that is equal to some prefix s[1:k‚àíj+1], where j cannot equal 1 (otherwise, P[k] would always equal k). By convention, P[1]=0.

Given: A DNA string s (of length at most 100 kbp) in FASTA format.

Return: The failure array of s.

######################Finding a Shared Spliced Motif####################################
######################http://rosalind.info/problems/lcsq/###############################

Locating Motifs Despite Intron

In ‚ÄúFinding a Shared Motif‚Äù, we discussed searching through a database containing multiple genetic strings to find a longest common substring of these strings, which served as a motif shared by the two strings. However, as we saw in ‚ÄúRNA Splicing‚Äù, coding regions of DNA are often interspersed by introns that do not code for proteins.

We therefore need to locate shared motifs that are separated across exons, which means that the motifs are not required to be contiguous. To model this situation, we need to enlist subsequences.

Problem

A string u is a common subsequence of strings s and t if the symbols of u appear in order as a subsequence of both s and t. For example, "ACTG" is a common subsequence of "AACCTTGG" and "ACACTGTGA".

Analogously to the definition of longest common substring, u is a longest common subsequence of s and t if there does not exist a longer common subsequence of the two strings. Continuing our above example, "ACCTTG" is a longest common subsequence of "AACCTTGG" and "ACACTGTGA", as is "AACTGG".

Given: Two DNA strings s and t (each having length at most 1 kbp) in FASTA format.

Return: A longest common subsequence of s and t. (If more than one solution exists, you may return any one.)

########################Ordering Strings of Varying Length Lexicographically############
########################http://rosalind.info/problems/lexv/#############################

Organizing Strings of Different Lengths

In ‚ÄúEnumerating k-mers Lexicographically‚Äù, we introduced the lexicographic order for strings of the same length constructed from some ordered underlying alphabet. However, our experience with dictionaries suggests that we should be able to order strings of different lengths just as easily. That is, we already have an intuitive sense that "APPLE" comes before "APPLET", which comes before "ARTS," and so we should be able to apply this intuition toward cataloguing genetic strings of varying lengths.

Problem

Say that we have strings s=s1s2‚ãØsm and t=t1t2‚ãØtn with m<n. Consider the substring t‚Ä≤=t[1:m]. We have two cases:

If s=t‚Ä≤, then we set s<Lext because s is shorter than t (e.g., APPLE<APPLET).
Otherwise, s‚â†t‚Ä≤. We define s<Lext if s<Lext‚Ä≤ and define s>Lext if s>Lext‚Ä≤ (e.g., APPLET<LexARTS because APPL<LexARTS).
Given: A permutation of at most 12 symbols defining an ordered alphabet ùíú and a positive integer n (n‚â§4).

Return: All strings of length at most n formed from ùíú, ordered lexicographically. (Note: As in ‚ÄúEnumerating k-mers Lexicographically‚Äù, alphabet order is based on the order in which the symbols are given.)

#########################Maximum Matchings and RNA Secondary Structures#################
#########################http://rosalind.info/problems/mmch/############################

Breaking the Bonds

In ‚ÄúPerfect Matchings and RNA Secondary Structures‚Äù, we considered a problem that required us to assume that every possible nucleotide is involved in base pairing to induce an RNA secondary structure. Yet the only way this could occur is if the frequency of adenine in our RNA strand is equal to the frequency of uracil and if the same holds for guanine and cytosine.

We will therefore begin to explore ways of counting secondary structures in which this condition is not required. A more general combinatorial problem will ask instead for the total number of secondary structures of a strand having a maximum possible number of base pairs.

Problem

The graph theoretical analogue of the quandary stated in the introduction above is that if we have an RNA string s that does not have the same number of occurrences of 'C' as 'G' and the same number of occurrences of 'A' as 'U', then the bonding graph of s cannot possibly possess a perfect matching among its basepair edges. For example, see Figure 1; in fact, most bonding graphs will not contain a perfect matching.

In light of this fact, we define a maximum matching in a graph as a matching containing as many edges as possible. See Figure 2 for three maximum matchings in graphs.

A maximum matching of basepair edges will correspond to a way of forming as many base pairs as possible in an RNA string, as shown in Figure 3.

Given: An RNA string s of length at most 100.

Return: The total possible number of maximum matchings of basepair edges in the bonding graph of s.

#######################Creating a Distance Matrix#######################################
#######################http://rosalind.info/problems/pdst/##############################

Introduction to Distance-Based Phylogeny

A number of different approaches are used to build phylogenies, each one featuring its own computational strengths and weaknesses. One of these measures is distance-based phylogeny, which constructs a tree from evolutionary distances calculated between pairs of taxa.

A wide assortment of different measures exist for quantifying this evolutionary distance. Once we have selected a distance function and used it to calculate the distance between every pair of taxa, we place these pairwise distance functions into a table.

In this problem, we will consider an evolutionary function based on Hamming distance. Recall from ‚ÄúCounting Point Mutations‚Äù that this function compares two homologous strands of DNA by counting the minimum possible number of point mutations that could have occurred on the evolutionary path between the two strands.

Problem

For two strings s1 and s2 of equal length, the p-distance between them, denoted dp(s1,s2), is the proportion of corresponding symbols that differ between s1 and s2.

For a general distance function d on n taxa s1,s2,‚Ä¶,sn (taxa are often represented by genetic strings), we may encode the distances between pairs of taxa via a distance matrix D in which Di,j=d(si,sj).

Given: A collection of n (n‚â§10) DNA strings s1,‚Ä¶,sn of equal length (at most 1 kbp). Strings are given in FASTA format.

Return: The matrix D corresponding to the p-distance dp on the given strings. As always, note that your answer is allowed an absolute error of 0.001.


#######################Reversal Distance################################################
#######################http://rosalind.info/problems/rear/##############################

Rearrangements Power Large-Scale Genomic Changes

Perhaps the most common type of genome rearrangement is an inversion, which flips an entire interval of DNA found on the same chromosome. As in the case of calculating Hamming distance (see ‚ÄúCounting Point Mutations‚Äù), we would like to determine the minimum number of inversions that have occurred on the evolutionary path between two chromosomes. To do so, we will use the model introduced in ‚ÄúEnumerating Gene Orders‚Äù in which a chromosome is represented by a permutation of its synteny blocks.

Problem

A reversal of a permutation creates a new permutation by inverting some interval of the permutation; (5,2,3,1,4), (5,3,4,1,2), and (4,1,2,3,5) are all reversals of (5,3,2,1,4). The reversal distance between two permutations œÄ and œÉ, written drev(œÄ,œÉ), is the minimum number of reversals required to transform œÄ into œÉ (this assumes that œÄ and œÉ have the same length).

Given: A collection of at most 5 pairs of permutations, all of which have length 10.

Return: The reversal distance between each permutation pair.

#######################Matching Random Motifs###########################################
#######################http://rosalind.info/problems/rstr/##############################

More Random Strings

In ‚ÄúIntroduction to Random Strings‚Äù, we discussed searching for motifs in large genomes, in which random occurrences of the motif are possible. Our aim is to quantify just how frequently random motifs occur.

One class of motifs of interest are promoters, or regions of DNA that initiate the transcription of a gene. A promoter is usually located shortly before the start of its gene, and it contains specific intervals of DNA that provide an initial binding site for RNA polymerase to initiate transcription. Finding a promoter is usually the second step in gene prediction after establishing the presence of an ORF (see ‚ÄúOpen Reading Frames‚Äù).

Unfortunately, there is no quick rule for identifying promoters. In Escherichia coli, the promoter contains two short intervals (TATAAT and TTGACA), which are respectively located 10 and 35 base pairs upstream from the beginning of the gene's ORF. Yet even these two short intervals are consensus strings (see ‚ÄúConsensus and Profile‚Äù): they represent average-case strings that are not found intact in most promoters. Bacterial promoters further vary in that some contain additional intervals used to bind to specific proteins or to change the intensity of transcription.

Eukaryotic promoters are even more difficult to characterize. Most have a TATA box (consensus sequence: TATAAA), preceded by an interval called a B recognition element, or BRE. These elements are typically located within 40 bp of the start of transcription. For that matter, eukaryotic promoters can hold a larger number of additional "regulatory" intervals, which can be found as far as several thousand base pairs upstream of the gene.


Problem

Our aim in this problem is to determine the probability with which a given motif (a known promoter, say) occurs in a randomly constructed genome. Unfortunately, finding this probability is tricky; instead of forming a long genome, we will form a large collection of smaller random strings having the same length as the motif; these smaller strings represent the genome's substrings, which we can then test against our motif.

Given a probabilistic event A, the complement of A is the collection Ac of outcomes not belonging to A. Because Ac takes place precisely when A does not, we may also call Ac "not A."

For a simple example, if A is the event that a rolled die is 2 or 4, then Pr(A)=13. Ac is the event that the die is 1, 3, 5, or 6, and Pr(Ac)=23. In general, for any event we will have the identity that Pr(A)+Pr(Ac)=1.

Given: A positive integer N‚â§100000, a number x between 0 and 1, and a DNA string s of length at most 10 bp.

Return: The probability that if N random DNA strings having the same length as s are constructed with GC-content x (see ‚ÄúIntroduction to Random Strings‚Äù), then at least one of the strings equals s. We allow for the same random string to be created more than once.


#########################Counting Subsets###############################################
#########################http://rosalind.info/problems/sset/############################

Characters and SNPs

A character is any feature (genetic, physical, etc.) that divides a collection of organisms into two separate groups. One commonly used genetic character is the possession of a single-nucleotide polymorphism, or SNP.

In a process called genotyping, the SNP markers taken from a large number of human donors have been used very successfully to catalogue the migration and differentiation of human populations over the last 200,000 years. For $199, you can participate in National Geographic's Genographic Project, and discover your own genetic heritage.

Whether we use genetic or physical characters, we may think of a collection of n characters as a collection of "ON"/"OFF" switches. An organism is said to possess a character in the "ON" position (although often the assignment of "ON"/"OFF" is arbitrary). Given a collection of taxa, we may represent a character by the collection of taxa possessing the character.


Problem

A set is the mathematical term for a loose collection of objects, called elements. Examples of sets include {the moon, the sun, Wilford Brimley} and ‚Ñù, the set containing all real numbers. We even have the empty set, represented by ‚àÖ or {}, which contains no elements at all. Two sets are equal when they contain the same elements. In other words, in contrast to permutations, the ordering of the elements of a set is unimportant (e.g., {the moon, the sun, Wilford Brimley} is equivalent to {Wilford Brimley, the moon, the sun}). Sets are not allowed to contain duplicate elements, so that {Wilford Brimley, the sun, the sun} is not a set. We have already used sets of 2 elements to represent edges from a graph.

A set A is a subset of B if every element of A is also an element of B, and we write A‚äÜB. For example, {the sun, the moon}‚äÜ{the sun, the moon, Wilford Brimley}, and ‚àÖ is a subset of every set (including itself!).

As illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character. However, the number of applications is endless; for example, an event in probability can now be defined as a subset of the set containing all possible outcomes.

Our first question is to count the total number of possible subsets of a given set.

Given: A positive integer n (n‚â§1000).

Return: The total number of subsets of {1,2,‚Ä¶,n} modulo 1,000,000.


########################Introduction to Alternative Splicing############################
########################http://rosalind.info/problems/aspc/#############################

The Baby and the Bathwater

However, the chaining of exons does not always proceed in the same manner; alternative splicing describes the fact that all the exons from a gene are not necessarily joined together in order to produce an mRNA. The most common form of alternative splicing is exon skipping, in which certain exons are omitted along with introns.

Alternative splicing serves a vital evolutionary purpose, as it greatly increases the number of different proteins that can be translated from a given gene; different proteins produced from the same gene as a result of alternative splicing are called protein isoforms; see Figure 1 In fact, about 95% of human genes are commonly spliced in more than one way. At the same time, when alternative splicing goes wrong, it can create the same negative effects caused by mutations, and it has been blamed for a number of genetic disorders.

In this problem, we will consider a simplified model of alternative splicing in which any of a collection of exons can be chained together to create a final molecule of mRNA, under the condition that we use a minimum number of exons (m) whose order is fixed. Because the exons are not allowed to move around, we need only select a subset of at least m of our exons to chain into an mRNA.

The implied computational question is to count the total number of such subsets, which will provide us with the total possible number of alternatively spliced isoforms for this model.

Problem

In ‚ÄúCounting Subsets‚Äù, we saw that the total number of subsets of a set S containing n elements is equal to 2n.

However, if we intend to count the total number of subsets of S having a fixed size k, then we use the combination statistic C(n,k), also written (nk).

Given: Positive integers n and m with 0‚â§m‚â§n‚â§2000.

Return: The sum of combinations C(n,k) for all k satisfying m‚â§k‚â§n, modulo 1,000,000. In shorthand, ‚àënk=m(nk).

#########################Edit Distance##################################################
#########################http://rosalind.info/problems/edit/############################

Point Mutations Include Insertions and Deletions

In ‚ÄúCounting Point Mutations‚Äù, we saw that Hamming distance gave us a preliminary notion of the evolutionary distance between two DNA strings by counting the minimum number of single nucleotide substitutions that could have occurred on the evolutionary path between the two strands.

However, in practice, homologous strands of DNA or protein are rarely the same length because point mutations also include the insertion or deletion of a single nucleotide (and single amino acids can be inserted or deleted from peptides). Thus, we need to incorporate these insertions and deletions into the calculation of the minimum number of point mutations between two strings. One of the simplest models charges a unit "cost" to any single-symbol insertion/deletion, then (in keeping with parsimony) requests the minimum cost over all transformations of one genetic string into another by point substitutions, insertions, and deletions.


Problem

Given two strings s and t (of possibly different lengths), the edit distance dE(s,t) is the minimum number of edit operations needed to transform s into t, where an edit operation is defined as the substitution, insertion, or deletion of a single symbol.

The latter two operations incorporate the case in which a contiguous interval is inserted into or deleted from a string; such an interval is called a gap. For the purposes of this problem, the insertion or deletion of a gap of length k still counts as k distinct edit operations.

Given: Two protein strings s and t in FASTA format (each of length at most 1000 aa).

Return: The edit distance dE(s,t).

#######################Expected Number of Restriction Sites#############################
#######################http://rosalind.info/problems/eval/##############################

A Shot in the Dark

In ‚ÄúLocating Restriction Sites‚Äù, we first familiarized ourselves with restriction enzymes. Recall that these enzymes are used by bacteria to cut through both strands of viral DNA, thus disarming the virus: the viral DNA locations where these cuts are made are known as restriction sites. Recall also that every restriction enzyme is preprogrammed with a reverse palindromic interval of DNA to which it will bind and cut, called a recognition sequence. These even length intervals are usually either 4 or 6 base pairs long, although longer ones do exist; rare-cutter enzymes have recognition sequences of 8 or more base pairs.

In this problem, we will ask a simple question: how does the bacterium "know" that it will probably succeed in finding a restriction site within the virus's DNA? The answer is that the short length of recognition sequences guarantees a large number of matches occurring randomly.

Intuitively, we would expect for a recognition sequence of length 6 to occur on average once every 46=4,096 base pairs. Note that this fact does not imply that the associated restriction enzyme will cut the viral DNA every 4,096 bp; it may find two restriction sites close together, then not find a restriction site for many thousand nucleotides.

In this problem, we will generalize the problem of finding an average number of restriction sites to take into account the GC-content of the underlying string being analyzed.


Problem

Say that you place a number of bets on your favorite sports teams. If their chances of winning are 0.3, 0.8, and 0.6, then you should expect on average to win 0.3 + 0.8 + 0.6 = 1.7 of your bets (of course, you can never win exactly 1.7!)

More generally, if we have a collection of events A1,A2,‚Ä¶,An, then the expected number of events occurring is Pr(A1)+Pr(A2)+‚ãØ+Pr(An) (consult the note following the problem for a precise explanation of this fact). In this problem, we extend the idea of finding an expected number of events to finding the expected number of times that a given string occurs as a substring of a random string.

Given: A positive integer n (n‚â§1,000,000), a DNA string s of even length at most 10, and an array A of length at most 20, containing numbers between 0 and 1.

Return: An array B having the same length as A in which B[i] represents the expected number of times that s will appear as a substring of a random DNA string t of length n, where t is formed with GC-content A[i] (see ‚ÄúIntroduction to Random Strings‚Äù).


#######################Motzkin Numbers and RNA Secondary Structures######################
#######################http://rosalind.info/problems/motz/###############################

The Dirty Truth About Mathematics Parties

In ‚ÄúCatalan Numbers and RNA Secondary Structures‚Äù, we talked about counting the number of ways for an even number of people to shake hands at a party without crossing hands. However, in the real world, parties only contain an even number of people about 30% of the time, and mathematicians aren't social butterflies. So we should instead count the total number of ways for some of the people at the party to shake hands without crossing.

In the biological world, people are perhaps more social, but not every nucleotide in a strand of RNA winds up base pairing with another nucleotide during RNA folding. As a result, we want to loosen this assumption and count the total number of different secondary structures of an RNA strand whose base pairs don't overlap (i.e., we still forbid pseudoknots in the strand).

Problem

Similarly to our definition of the Catalan numbers, the n-th Motzkin number mn counts the number of ways to form a (not necessarily perfect) noncrossing matching in the complete graph Kn containing n nodes. For example, Figure 1 demonstrates that m5=21. Note in this figure that technically, the "trivial" matching that contains no edges at all is considered to be a matching, because it satisfies the defining condition that no two edges are incident to the same node.

How should we compute the Motzkin numbers? As with Catalan numbers, we will take m0=m1=1. To calculate mn in general, assume that the nodes of Kn are labeled around the outside of a circle with the integers between 1 and n, and consider node 1, which may or may not be involved in a matching. If node 1 is not involved in a matching, then there are mn‚àí1 ways of matching the remaining n‚àí1 nodes. If node 1 is involved in a matching, then say it is matched to node k: this leaves k‚àí2 nodes on one side of edge {1,k} and n‚àík nodes on the other side; as with the Catalan numbers, no edge can connect the two sides, which gives us mk‚àí2‚ãÖmn‚àík ways of matching the remaining edges. Allowing k to vary between 2 and n yields the following recurrence relation for the Motzkin numbers: mn=mn‚àí1+‚àënk=2mk‚àí2‚ãÖmn‚àík.

To count all possible secondary structures of a given RNA string that do not contain pseudoknots, we need to modify the Motzkin recurrence so that it counts only matchings of basepair edges in the bonding graph corresponding to the RNA string; see Figure 2.

Given: An RNA string s of length at most 300 bp.

Return: The total number of noncrossing matchings of basepair edges in the bonding graph of s, modulo 1,000,000.


#####################Distances in Trees############################################
#####################http://rosalind.info/problems/nwck/###########################

Paths in Trees

For any two nodes of a tree, a unique path connects the nodes; more specifically, there is a unique path connecting any pair of leaves. Why must this be the case? If more than one path connected two nodes, then they would necessarily form a cycle, which would violate the definition of tree.

The uniqueness of paths connecting nodes in a tree is helpful in phylogenetic analysis because a rudimentary measure of the separation between two taxa is the distance between them in the tree, which is equal to the number of edges on the unique path connecting the two leaves corresponding to the taxa.


Problem

Newick format is a way of representing trees even more concisely than using an adjacency list, especially when dealing with trees whose internal nodes have not been labeled.

First, consider the case of a rooted tree T. A collection of leaves v1,v2,‚Ä¶,vn of T are neighbors if they are all adjacent to some internal node u. Newick format for T is obtained by iterating the following key step: delete all the edges {vi,u} from T and label u with (v1,v2,‚Ä¶,vn)u. This process is repeated all the way to the root, at which point a semicolon signals the end of the tree.

A number of variations of Newick format exist. First, if a node is not labeled in T, then we simply leave blank the space occupied by the node. In the key step, we can write (v1,v2,‚Ä¶,vn) in place of (v1,v2,‚Ä¶,vn)u if the vi are labeled; if none of the nodes are labeled, we can write (,,‚Ä¶,).

A second variation of Newick format occurs when T is unrooted, in which case we simply select any internal node to serve as the root of T. A particularly peculiar case of Newick format arises when we choose a leaf to serve as the root.

Note that there will be a large number of different ways to represent T in Newick format; see Figure 1.

Given: A collection of n trees (n‚â§40) in Newick format, with each tree containing at most 200 nodes; each tree Tk is followed by a pair of nodes xk and yk in Tk.

Return: A collection of n positive integers, for which the kth integer represents the distance between xk and yk in Tk.




#####################Interleaving Two Motifs###################################
#####################http://rosalind.info/problems/scsp/#####################


Two Motifs, One Gene

Recall that in ‚ÄúFinding a Shared Spliced Motif‚Äù, we found the longest motif that could have been shared by two genetic strings, allowing for the motif to be split onto multiple exons in the process. As a result, we needed to find a longest common subsequence of the two strings (which extended the problem of finding a longest common substring from ‚ÄúFinding a Shared Motif‚Äù).

In this problem, we consider an inverse problem of sorts in which we are given two different motifs and we wish to interleave them together in such a way as to produce a shortest possible genetic string in which both motifs occur as subsequences.



Problem

A string s is a supersequence of another string t if s contains t as a subsequence.

A common supersequence of strings s and t is a string that serves as a supersequence of both s and t. For example, "GACCTAGGAACTC" serves as a common supersequence of "ACGTC" and "ATAT". A shortest common supersequence of s and t is a supersequence for which there does not exist a shorter common supersequence. Continuing our example, "ACGTACT" is a shortest common supersequence of "ACGTC" and "ATAT".

Given: Two DNA strings s and t.

Return: A shortest common supersequence of s and t. If multiple solutions exist, you may output any one.




#####################Introduction to Set Operations#####################
#####################http://rosalind.info/problems/seto/#####################

Forming New Sets

Just as numbers can be added, subtracted, and multiplied, we can manipulate sets in certain basic ways. The natural operations on sets are to combine their elements, to find those elements common to both sets, and to determine which elements belong to one set but not another.

Just as graph theory is the mathematical study of graphs and their properties, set theory is the mathematical study of sets and their properties.



Problem

If A and B are sets, then their union A‚à™B is the set comprising any elements in either A or B; their intersection A‚à©B is the set of elements in both A and B; and their set difference A‚àíB is the set of elements in A but not in B.

Furthermore, if A is a subset of another set U, then the set complement of A with respect to U is defined as the set Ac=U‚àíA. See the Sample sections below for examples.

Given: A positive integer n (n‚â§20,000) and two subsets A and B of {1,2,‚Ä¶,n}.

Return: Six sets: A‚à™B, A‚à©B, A‚àíB, B‚àíA, Ac, and Bc (where set complements are taken with respect to {1,2,‚Ä¶,n}).




#####################Sorting by Reversals##########################################
#####################http://rosalind.info/problems/sort/#####################

Reconstructing Evolutionary Histories

When we calculate the Hamming distance between two genetic strings, we can easily infer a collection of point mutations that occurred on the evolutionary path between the two strings by simply examining the mismatched symbols. However, when calculating the reversal distance (see ‚ÄúReversal Distance‚Äù), we only have the minimum number of reversals separating two permutations.

The computational problem of sorting by reversals demands instead that we provide a minimum list of reversals transforming one permutation into another. As a result, sorting by reversals subsumes the calculation of reversal distance: once we have a minimum collection of reversals, the reversal distance follows immediately.


Problem

A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms (4,1,2,6,3,5) into (4,1,3,6,2,5) is encoded by [3,5].

A collection of reversals sorts œÄ into Œ≥ if the collection contains drev(œÄ,Œ≥) reversals, which when successively applied to œÄ yield Œ≥.

Given: Two permutations œÄ and Œ≥, each of length 10.

Return: The reversal distance drev(œÄ,Œ≥), followed by a collection of reversals sorting œÄ into Œ≥. If multiple collections of such reversals exist, you may return any one.


#####################Inferring Protein from Spectrum#####################
#####################http://rosalind.info/problems/spec/#####################


Introduction to Mass Spectrometry

In ‚ÄúCalculating Protein Mass‚Äù, we briefly mentioned an analytic chemical method called mass spectrometry, which aims to measure the mass-to-charge ratio of a particle or a molecule. In a mass spectrometer, a sample is vaporized (turned into gas), and then particles from the sample are ionized. The resulting ions are placed into an electromagnetic field, which separates them based on their charge and mass. The output of the mass spectrometer is a mass spectrum, or a plot of ions' possible mass-to-charge ratio values with the intensity (actual observed frequency) of ions having these mass-to-charge values.

For the moment, we will ignore charge and consider a list of the ions' monoisotopic masses as a simplified spectrum. Researchers do not possess cheap technology to go in and examine a protein one amino acid at a time (molecules are too submicroscopic). Instead, to determine a protein's structure, we will split several copies of the protein into smaller pieces, then weigh the resulting fragments. To do this, we assume that each cut (breakage point) occurs between two amino acids and that we can measure the mass of the resulting pieces for all possible cuts.

For example, the (unknown) protein "PRTEIN" can be cut in five possible ways: "P" and "RTEIN"; "PR" and "TEIN"; "PRT" and "EIN"; "PRTE" and "IN"; "PRTEI" and "N". We then can measure the masses of all fragments, including the entire string. The "left" end of a protein is called its N-terminus, and the ions corresponding to the protein string's prefixes (P, PR, PRT, PRTE, PRTEI) are called b-ions. The "right" end of the protein is called its C-terminus, and the ions corresponding to the string's suffixes (N, IN, EIN, TEIN, RTEIN) are called y-ions. The difference in the masses of two adjacent b-ions (or y-ions) gives the mass of one amino acid residue; for example, the difference between the masses of "PRT" and "PR" must be the mass of "T." By extension, knowing the masses of every b-ion of a protein allows us to deduce the protein's identity.


Problem

The prefix spectrum of a weighted string is the collection of all its prefix weights.

Given: A list L of n (n‚â§100) positive real numbers.

Return: A protein string of length n‚àí1 whose prefix spectrum is equal to L (if multiple solutions exist, you may output any one of them). Consult the monoisotopic mass table.



#####################Introduction to Pattern Matching#####################
#####################http://rosalind.info/problems/trie/#####################


If At First You Don't Succeed...

We introduced the problem of finding a motif in a genetic string in ‚ÄúFinding a Motif in DNA‚Äù. More commonly, we will have a collection of motifs that we may wish to find in a larger string, for example when searching a genome for a collection of known genes.

This application sets up the algorithmic problem of pattern matching, in which we are searching a large string (called a text) for instances of a collection of smaller strings, called patterns. For the moment, we will focus on requiring that all matches should be exact.

The most obvious method for finding exact patterns in a text is to simply apply a simple "sliding window" algorithm for each pattern. However, this method is time-consuming if we have a large number of patterns to consider (which will often be the case when dealing with a database of genes). It would be better if instead of traversing the genome for every pattern, we could somehow only traverse it once. To this end, we will need a data structure that can efficiently organize a collection of patterns.



Problem


We may then iterate the process by moving down one level as follows. Say that an edge connecting the root to a node v is labeled with 'A'; then we delete the first symbol from every string in the collection beginning with 'A' and then treat v as our root. We apply this process to all nodes that are adjacent to the root, and then we move down another level and continue. See Figure 1 for an example of a trie.

As a result of this method of construction, the symbols along the edges of any path in the trie from the root to a leaf will spell out a unique string from the collection, as long as no string is a prefix of another in the collection (this would cause the first string to be encoded as a path terminating at an internal node).

Given: A list of at most 100 DNA strings of length at most 100 bp, none of which is a prefix of another.

Return: The adjacency list corresponding to the trie T for these patterns, in the following format. If T has n nodes, first label the root with 1 and then label the remaining nodes with the integers 2 through n in any order you like. Each edge of the adjacency list of T will be encoded by a triple containing the integer representing the edge's parent node, followed by the integer representing the edge's child node, and finally the symbol labeling the edge.




#####################Comparing Spectra with the Spectral Convolution##############
#####################http://rosalind.info/problems/conv/#####################


Comparing Spectra

Suppose you have two mass spectra, and you want to check if they both were obtained from the same protein; you will need some notion of spectra similarity. The simplest possible metric would be to count the number of peaks in the mass spectrum that the spectra share, called the shared peaks count; its analogue for simplified spectra is the number of masses that the two spectra have in common.

The shared peaks count can be useful in the simplest cases, but it does not help us if, for example, one spectrum corresponds to a peptide contained inside of another peptide from which the second spectrum was obtained. In this case, the two spectra are very similar, but the shared peaks count will be very small. However, if we shift one spectrum to the right or left, then shared peaks will align. In the case of simplified spectra, this means that there is some shift value x such that adding x to the weight of every element in one spectrum should create a large number of matches in the other spectrum.


Problem

A multiset is a generalization of the notion of set to include a collection of objects in which each object may occur more than once (the order in which objects are given is still unimportant). For a multiset S, the multiplicity of an element x is the number of times that x occurs in the set; this multiplicity is denoted S(x). Note that every set is included in the definition of multiset.

The Minkowski sum of multisets S1 and S2 containing real numbers is the new multiset S1‚äïS2 formed by taking all possible sums s1+s2 of an element s1 from S1 and an element s2 from S2. The Minkowski sum could be defined more concisely as S1‚äïS2=s1+s2:s1‚ààS1,s2‚ààS2, The Minkowski difference S1‚äñS2 is defined analogously by taking all possible differences s1‚àís2.

If S1 and S2 represent simplified spectra taken from two peptides, then S1‚äñS2 is called the spectral convolution of S1 and S2. In this notation, the shared peaks count is represented by (S2‚äñS1)(0), and the value of x for which (S2‚äñS1)(x) has the maximal value is the shift value maximizing the number of shared masses of S1 and S2.

Given: Two multisets of positive real numbers S1 and S2. The size of each multiset is at most 200.

Return: The largest multiplicity of S1‚äñS2, as well as the absolute value of the number x maximizing (S1‚äñS2)(x) (you may return any such value if multiple solutions exist).



#####################Creating a Character Table#####################
#####################http://rosalind.info/problems/ctbl/#####################


Introduction to Character-Based Phylogeny

Before the modern genetics revolution, phylogenies were constructed from physical characters resulting from direct structural comparison of taxa. A great deal of analysis relied on the fossil record, as fossils provided the only concrete framework for studying the appearance of extinct species and for inferring how they could have evolved into present-day organisms.

A classic case illustrating the utility of the fossil record is the case of dinosaur pelvic bones. In 1887, Harry Seeley proposed a new classification of dinosaurs into two orders, Saurischia and Ornithischia: the former possessed hip bones shaped like those found in reptiles, whereas the latter had a much different hip shape that resembled birds. Seeley's pelvic classification has survived to the present day as the principal division of dinosaurs.

The key point is that hip bone shape is a physical character that separates all dinosaurs into two different groups. Our hope is to construct a phylogeny solely from a collection of characters. Throughout character-based phylogeny, our two-part assumption is that all taxa possessing a character must have evolved from a single ancestor that introduced this character, and conversely, any taxon not possessing the character cannot be descended from this ancestor.



Problem

Given a collection of n taxa, any subset S of these taxa can be seen as encoding a character that divides the taxa into the sets S and Sc; we can represent the character by S‚à£Sc, which is called a split. Alternately, the character can be represented by a character array A of length n for which A[j]=1 if the jth taxon belongs to S and A[j]=0 if the jth taxon belongs to Sc (recall the "ON"/"OFF" analogy from ‚ÄúCounting Subsets‚Äù).

At the same time, observe that the removal of an edge from an unrooted binary tree produces two separate trees, each one containing a subset of the original taxa. So each edge may also be encoded by a split S‚à£Sc.

A trivial character isolates a single taxon into a group of its own. The corresponding split S‚à£Sc must be such that S or Sc contains only one element; the edge encoded by this split must be incident to a leaf of the unrooted binary tree, and the array for the character contains exactly one 0 or exactly one 1. Trivial characters are of no phylogenetic interest because they fail to provide us with information regarding the relationships of taxa to each other. All other characters are called nontrivial characters (and the associated splits are called nontrivial splits).

A character table is a matrix C in which each row represents the array notation for a nontrivial character. That is, entry Ci,j denotes the "ON"/"OFF" position of the ith character with respect to the jth taxon.

Given: An unrooted binary tree T in Newick format for at most 200 species taxa.

Return: A character table having the same splits as the edge splits of T. The columns of the character table should encode the taxa ordered lexicographically; the rows of the character table may be given in any order. Also, for any given character, the particular subset of taxa to which 1s are assigned is arbitrary.



#####################Constructing a De Bruijn Graph#####################
#####################http://rosalind.info/problems/dbru/#####################

Wading Through the Reads

Because we use multiple copies of the genome to generate and identify reads for the purposes of fragment assembly, the total length of all reads will be much longer than the genome itself. This begs the definition of read coverage as the average number of times that each nucleotide from the genome appears in the reads. In other words, if the total length of our reads is 30 billion bp for a 3 billion bp genome, then we have 10x read coverage.

To handle such a large number of k-mers for the purposes of sequencing the genome, we need an efficient and simple structure.



Problem

Consider a set S of (k+1)-mers of some unknown DNA string. Let Src denote the set containing all reverse complements of the elements of S. (recall from ‚ÄúCounting Subsets‚Äù that sets are not allowed to contain duplicate elements).

The de Bruijn graph Bk of order k corresponding to S‚à™Src is a digraph defined in the following way:

Nodes of Bk correspond to all k-mers that are present as a substring of a (k+1)-mer from S‚à™Src.
Edges of Bk are encoded by the (k+1)-mers of S‚à™Src in the following way: for each (k+1)-mer r in S‚à™Src, form a directed edge (r[1:k], r[2:k+1]).
Given: A collection of up to 1000 DNA strings of equal length (not exceeding 50 bp) corresponding to a set S of (k+1)-mers.

Return: The adjacency list corresponding to the de Bruijn graph corresponding to S‚à™Src.


#####################Edit Distance Alignment#####################
#####################http://rosalind.info/problems/edta/#####################

Reconstructing Edit Distance

In ‚ÄúCounting Point Mutations‚Äù, the calculation of Hamming distance gave us a clear way to model the sequence of point mutations transforming one genetic string into another. By simply writing one string directly over the other, we could count each mismatched symbol as a substitution.

However, in the calculation of edit distance (see ‚ÄúEdit Distance‚Äù), the two strings can have different lengths; thus, simply superimposing one string over the other does us no good when it comes to visualizing a sequence of edit operations transforming one string into the other. To remedy this, we will introduce a new symbol to serve as a placeholder representing an inserted or deleted symbol; furthermore, this placeholder will allow us to align two strings of differing lengths.



Problem

An alignment of two strings ss and tt is defined by two strings s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ satisfying the following three conditions: 1. s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ must be formed from adding gap symbols "-" to each of ss and tt, respectively; as a result, ss and tt will form subsequences of s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤. 2. s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ must have the same length. 3. Two gap symbols may not be aligned; that is, if s‚Ä≤[j]s‚Ä≤[j] is a gap symbol, then t‚Ä≤[j]t‚Ä≤[j] cannot be a gap symbol, and vice-versa.

We say that s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ augment ss and tt. Writing s‚Ä≤s‚Ä≤ directly over t‚Ä≤t‚Ä≤ so that symbols are aligned provides us with a scenario for transforming ss into tt. Mismatched symbols from ss and tt correspond to symbol substitutions; a gap symbol s‚Ä≤[j]s‚Ä≤[j] aligned with a non-gap symbol t‚Ä≤[j]t‚Ä≤[j] implies the insertion of this symbol into tt; a gap symbol t‚Ä≤[j]t‚Ä≤[j] aligned with a non-gap symbol s‚Ä≤[j]s‚Ä≤[j] implies the deletion of this symbol from ss.

Thus, an alignment represents a transformation of ss into tt via edit operations. We define the corresponding edit alignment score of s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ as dH(s‚Ä≤,t‚Ä≤)dH(s‚Ä≤,t‚Ä≤) (Hamming distance is used because the gap symbol has been introduced for insertions and deletions). It follows that dE(s,t)=mins‚Ä≤,t‚Ä≤dH(s‚Ä≤,t‚Ä≤)dE(s,t)=mins‚Ä≤,t‚Ä≤dH(s‚Ä≤,t‚Ä≤), where the minimum is taken over all alignments of ss and tt. We call such a minimum score alignment an optimal alignment (with respect to edit distance).

Given: Two protein strings ss and tt in FASTA format (with each string having length at most 1000 aa).

Return: The edit distance dE(s,t)dE(s,t) followed by two augmented strings s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ representing an optimal alignment of ss and tt.



#####################Inferring Peptide from Full Spectrum#####################
#####################http://rosalind.info/problems/full/#####################


Ions Galore

In ‚ÄúInferring Protein from Spectrum‚Äù, we inferred a protein string from a list of b-ions. In practice, biologists have no way of distinguishing between b-ions and y-ions in the simplified spectrum of a peptide. However, we will often possess a pair of masses in the spectrum corresponding to a single cut. The two corresponding ions complement each other: for example, mass("PR") + mass("TEIN") = mass("PRTEIN"). As a result, we can easily infer the mass of a b-ion from its complementary y-ion and vice versa, as long as we already know the parent mass, i.e., the mass of the entire peptide.

The theoretical simplified spectrum for a protein PP of length nn is constructed as follows: form all possible cuts, then compute the mass of the b-ion and the y-ion at each cut. Duplicate masses are allowed. You might guess how we could modify ‚ÄúInferring Protein from Spectrum‚Äù to infer a peptide from its theoretical simplified spectrum; here we consider a slightly modified form of this problem in which we attempt to identify the interior region of a peptide given only b-ions and y-ions that are cut within this region. As a result, we will have constant masses at the beginning and end of the peptide that will be present in the mass of every b-ion and y-ion, respectively.

Problem

Say that we have a string ss containing tt as an internal substring, so that there exist nonempty substrings s1s1 and s2s2 of ss such that ss can be written as s1ts2s1ts2. A t-prefix contains all of s1s1 and none of s2s2; likewise, a t-suffix contains all of s2s2 and none of s1s1.

Given: A list LL containing 2n+32n+3 positive real numbers (n‚â§100n‚â§100). The first number in LL is the parent mass of a peptide PP, and all other numbers represent the masses of some b-ions and y-ions of PP (in no particular order). You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.

Return: A protein string tt of length nn for which there exist two positive real numbers w1w1 and w2w2 such that for every prefix pp and suffix ss of tt, each of w(p)+w1w(p)+w1 and w(s)+w2w(s)+w2 is equal to an element of LL. (In other words, there exists a protein string whose tt-prefix and tt-suffix weights correspond to the non-parent mass values of LL.) If multiple solutions exist, you may output any one.


#####################Independent Segregation of Chromosomes#####################
#####################http://rosalind.info/problems/indc/#####################

Mendel's Work Examined

Mendel's laws of heredity were initially ignored, as only 11 papers have been found that cite his paper between its publication in 1865 and 1900. One reason for Mendel's lack of popularity is that information did not move quite so readily as in the modern age; perhaps another reason is that as a friar in an Austrian abbey, Mendel was already isolated from Europe's university community.

It is fair to say that no one who did initially read Mendel's work fully believed that traits for more complex organisms, like humans, could be broken down into discrete units of heredity (i.e., Mendel's factors). This skepticism was well-founded in empirical studies of inheritance, which indicated a far more complex picture of heredity than Mendel's theory dictated. The friar himself admitted that representing every trait with a single factor was overly simplistic, and so he proposed that some traits are polymorphic, or encoded by multiple different factors.

Yet any hereditary model would ultimately be lacking without an understanding of how traits are physically passed from organisms to their offspring. This physical mechanism was facilitated by Walther Flemming's 1879 discovery of chromosomes in salamander eggs during cell division, followed by Theodor Boveri's observation that sea urchin embryos with chromatin removed failed to develop correctly (implying that traits must somehow be encoded on chromosomes). By the turn of the 20th century, Mendel's work had been rediscovered by Hugo de Vries and Carl Correns, but it was still unclear how Mendel's hereditary model could be tied to chromosomes.

Fortunately, Walter Sutton demonstrated that grasshopper chromosomes occur in matched pairs called homologous chromosomes, or homologs. We now know that the DNA found on homologous chromosomes is identical except for minor variations attributable to SNPs and small rearrangements, which are typically insertions and deletions. Sutton himself, working five decades before Watson & Crick and possessing no real understanding of DNA, actually surmised that variations to homologous chromosomes should somehow correspond to Mendel's alleles.

Yet it still remained to show how chromosomes themselves are inherited. Most multicellular organisms are diploid, meaning that their cells possess two sets of chromosomes; humans are included among diploid organisms, having 23 homologous chromosome pairs.

Gametes (i.e., sex cells) in diploid organisms form an exception and are haploid, meaning that they only possess one chromosome from each pair of homologs. During the fusion of two gametes of opposite sex, a diploid embryo is formed by simply uniting the two gametes' halved chromosome sets.

Mendel's first law can now be explained by the fact that during the meiosis each gamete randomly selects one of the two available alleles of the particular gene.

Mendel's second law follows from the fact that gametes select nonhomologous chromosomes independently of each other; however, this law will hold only for factors encoded on nonhomologous chromosomes, which leaves open the inheritance of factors encoded on homologous chromosomes.


Problem

Consider a collection of coin flips. One of the most natural questions we can ask is if we flip a coin 92 times, what is the probability of obtaining 51 "heads", vs. 27 "heads", vs. 92 "heads"?

Each coin flip can be modeled by a uniform random variable in which each of the two outcomes ("heads" and "tails") has probability equal to 1/2. We may assume that these random variables are independent (see ‚ÄúIndependent Alleles‚Äù); in layman's terms, the outcomes of the two coin flips do not influence each other.

A binomial random variable XX takes a value of kk if nn consecutive "coin flips" result in kk total "heads" and n‚àíkn‚àík total "tails." We write that X‚ààBin(n,1/2)X‚ààBin(n,1/2).

Given: A positive integer n‚â§50n‚â§50.

Return: An array AA of length 2n2n in which A[k]A[k] represents the common logarithm of the probability that two diploid siblings share at least kk of their 2n2n chromosomes (we do not consider recombination for now).



#####################Finding Disjoint Motifs in a Gene#####################
#####################http://rosalind.info/problems/itwv/#####################

Disjoint Motifs

In this problem, we will consider an algorithmic (but not particularly practical) variant of motif finding for multiple motifs. Say we have two motifs corresponding to the coding regions of genes, and we want to know whether these motifs can be found in genes occupying the same region of the genome. To prevent exons from coinciding, we further stipulate that the two motifs are nonoverlapping.

In this problem, we will ask whether two disjoint motifs can be located in a given string. We considered a similar problem in ‚ÄúInterleaving Two Motifs‚Äù, which asked us to find a shortest possible string containing two motifs; however, in that problem, the motifs were allowed to coincide.


Problem

Given three strings ss, tt, and uu, we say that tt and uu can be interwoven into ss if there is some substring of ss made up of tt and uu as disjoint subsequences.

For example, the strings "ACAGACAG" and "CCGCCG" can be interwoven into "GACCACGGTTGACCACGGTT". However, they cannot be interwoven into "GACCACAAAAGGTTGACCACAAAAGGTT" because of the appearance of the four 'A's in the middle of the subsequences. Similarly, even though both "ACACGACACG" is a shortest common supersequence of ACAGACAG and CCGCCG, it is not possible to interweave these two strings into "ACACGACACG" because the two desired subsequences must be disjoint; see ‚ÄúInterleaving Two Motifs‚Äù for details on finding a shortest common supersequence of two strings.

Given: A text DNA string ss of length at most 10 kbp, followed by a collection of nn (n‚â§10n‚â§10) DNA strings of length at most 10 bp acting as patterns.

Return: An n√ónn√ón matrix MM for which Mj,k=1Mj,k=1 if the jjth and kkth pattern strings can be interwoven into ss and Mj,k=0Mj,k=0 otherwise.

#####################Finding the Longest Multiple Repeat#####################
#####################http://rosalind.info/problems/lrep/#####################


Long Repeats

We saw in ‚ÄúIntroduction to Pattern Matching‚Äù that a data structure commonly used to encode the relationships among a collection of strings was the trie, which is particularly useful when the strings represent a collection of patterns that we wish to match to a larger text.

The trie is helpful when processing multiple strings at once, but when we want to analyze a single string, we need something different.

In this problem, we will use a new data structure to handle the problem of finding long repeats in the genome. Recall from ‚ÄúFinding a Motif in DNA‚Äù that cataloguing these repeats is a problem of the utmost interest to molecular biologists, as a natural correlation exists between the frequency of a repeat and its influence on RNA transcription. Our aim is therefore to identify long repeats that occur more than some predetermined number of times.


Problem

A repeated substring of a string ss of length nn is simply a substring that appears in more than one location of ss; more specifically, a k-fold substring appears in at least k distinct locations.

The suffix tree of ss, denoted T(s)T(s), is defined as follows:

T(s) is a rooted tree having exactly nn leaves.
Every edge of T(s)T(s) is labeled with a substring of s‚àós‚àó, where s‚àós‚àó is the string formed by adding a placeholder symbol $ to the end of ss.
Every internal node of T(s)T(s) other than the root has at least two children; i.e., it has degree at least 3.
The substring labels for the edges leading from a node to its children must begin with different symbols.
By concatenating the substrings along edges, each path from the root to a leaf corresponds to a unique suffix of s‚àós‚àó.
See Figure 1 for an example of a suffix tree.

Given: A DNA string ss (of length at most 20 kbp) with $ appended, a positive integer kk, and a list of edges defining the suffix tree of ss. Each edge is represented by four components:

1. the label of its parent node in T(s)T(s);
2. the label of its child node in T(s)T(s);
3. the location of the substring tt of s‚àós‚àó assigned to the edge; and
4. the length of tt.
Return: The longest substring of ss that occurs at least kk times in ss. (If multiple solutions exist, you may return any single solution.)



#####################Newick Format with Edge Weights#####################
#####################http://rosalind.info/problems/nkew/#####################

Weighting the Tree

A vital goal of creating phylogenies is to quantify a molecular clock that indicates the amount of evolutionary time separating two members of the phylogeny. To this end, we will assign numbers to the edges of a tree so that the number assigned to an edge represents the amount of time separating the two species at each end of the edge. More generally, the evolutionary time between any two species will be given by simply adding the individual times connecting the nodes.


Problem

In a weighted tree, each edge is assigned a (usually positive) number, called its weight. The distance between two nodes in a weighted tree becomes the sum of the weights along the unique path connecting the nodes.

To generalize Newick format to the case of a weighted tree TT, during our repeated "key step," if leaves v1,v2,‚Ä¶,vnv1,v2,‚Ä¶,vn are neighbors in TT, and all these leaves are incident to uu, then we replace uu with (v1:d1,v2:d2,‚Ä¶,vn:dn)u(v1:d1,v2:d2,‚Ä¶,vn:dn)u, where didi is now the weight on the edge {vi,u}{vi,u}.

Given: A collection of n weighted trees (n‚â§40n‚â§40) in Newick format, with each tree containing at most 200 nodes; each tree TkTk is followed by a pair of nodes xk and yk in Tk.

Return: A collection of n numbers, for which the kth number represents the distance between xk and yk in Tk.


#####################Wobble Bonding and RNA Secondary Structures#####################
#####################http://rosalind.info/problems/rnas/#####################

Don't Look Down

We have discussed the problem of counting RNA secondary structures in previous problems. In this problem, we will add some assumptions to those used in ‚ÄúMotzkin Numbers and RNA Secondary Structures‚Äù to provide ourselves with an ultimately robust way of counting feasible RNA secondary structures.

First, in addition to the classic Watson and Crick base pairing of adenine with uracil and cytosine with guanine, uracil sometimes bonds with guanine, forming what is called a wobble base pair. As a result, we would like to allow wobble base pairing.

Second, although RNA folds over itself during base pairing, the structure of the molecule is rigid enough to prevent bases located very close to each other on the strand from bonding to each other.


Problem

Given an RNA string ss, we will augment the bonding graph of ss by adding basepair edges connecting all occurrences of 'U' to all occurrences of 'G' in order to represent possible wobble base pairs.

We say that a matching in the bonding graph for ss is valid if it is noncrossing (to prevent pseudoknots) and has the property that a basepair edge in the matching cannot connect symbols sjsj and sksk unless k‚â•j+4k‚â•j+4 (to prevent nearby nucleotides from base pairing).

See Figure 1 for an example of a valid matching if we allow wobble base pairs. In this problem, we will wish to count all possible valid matchings in a given bonding graph; see Figure 2 for all possible valid matchings in a small bonding graph, assuming that we allow wobble base pairing.

Given: An RNA string ss (of length at most 200 bp).

Return: The total number of distinct valid matchings of basepair edges in the bonding graph of ss. Assume that wobble base pairing is allowed.


#####################Counting Disease Carriers#####################
#####################http://rosalind.info/problems/afrq/#####################

Genetic Drift and the Hardy-Weinberg Principle

Mendel's laws of segration and independent assortment are excellent for the study of individual organisms and their progeny, but they say nothing about how alleles move through a population over time. Our first question is: when can we assume that the ratio of an allele in a population, called the allele frequency, is stable?

G. H. Hardy and Wilhelm Weinberg independently considered this question at the turn of the 20th Century, shortly after Mendel's ideas had been rediscovered. They concluded that the percentage of an allele in a population of individuals is in genetic equilibrium when five conditions are satisfied:

1. The population is so large that random changes in the allele frequency are negligible.
2. No new mutations are affecting the gene of interest;
3. The gene does not influence survival or reproduction, so that natural selection is not occurring;
4. Gene flow, or the change in allele frequency due to migration into and out of the population, is negligible.
5. Mating occurs randomly with respect to the gene of interest.
The Hardy-Weinberg principle states that if a population is in genetic equilibrium for a given allele, then its frequency will remain constant and evenly distributed through the population. Unless the gene in question is important to survival or reproduction, Hardy-Weinberg usually offers a reasonable enough model of population genetics.

One of the many benefits of the Mendelian theory of inheritance and simplifying models like Hardy-Weinberg is that they help us predict the probability with which genetic diseases will be inherited, so as to take appropriate preventative measures. Genetic diseases are usually caused by mutations to chromosomes, which are passed on to subsequent generations.

The simplest and most widespread case of a genetic disease is a single gene disorder, which is caused by a single mutated gene. Over 4,000 such human diseases have been identified, including cystic fibrosis and sickle-cell anemia. In both of these cases, the individual must possess two recessive alleles for a gene in order to contract the disease. Thus, carriers can live their entire lives without knowing that they can pass the disease on to their children.

The above introduction to genetic equilibrium leaves us with a basic and yet very practical question regarding gene disorders: if we know the number of people who have a disease encoded by a recessive allele, can we predict the number of carriers in the population?


Problem

To model the Hardy-Weinberg principle, assume that we have a population of NN diploid individuals. If an allele is in genetic equilibrium, then because mating is random, we may view the 2N2N chromosomes as receiving their alleles uniformly. In other words, if there are mm dominant alleles, then the probability of a selected chromosome exhibiting the dominant allele is simply p=m2Np=m2N.

Because the first assumption of genetic equilibrium states that the population is so large as to be ignored, we will assume that NN is infinite, so that we only need to concern ourselves with the value of pp.

Given: An array AA for which A[k] represents the proportion of homozygous recessive individuals for the k-th Mendelian factor in a diploid population. Assume that the population is in genetic equilibrium for all factors.

Return: An array BB having the same length as A in which B[k] represents the probability that a randomly selected individual carries at least one copy of the recessive allele for the k-th factor.

#####################Creating a Character Table from Genetic Strings#################
#####################http://rosalind.info/problems/cstr/#####################


Phylogeny from Genetic Characters

In ‚ÄúCreating a Character Table‚Äù, we introduced the character table as a way of representing a number of characters simultaneously. In that problem, we found a character table representing an unrooted binary tree on a collection of taxa.

Of course, in practice, the problem operates in reverse. We first need to generate a character table before we can model a phylogeny on this table. In modern genetics, a reliable way to obtain a large number of characters is by using SNPs. As mentioned in ‚ÄúCounting Subsets‚Äù, for a given SNP, we can divide taxa into two sets depending on which of two bases is present at the nucleotide, thus defining the split of a character.


Problem

A collection of strings is characterizable if there are at most two possible choices for the symbol at each position of the strings.

Given: A collection of at most 100 characterizable DNA strings, each of length at most 300 bp.

Return: A character table for which each nontrivial character encodes the symbol choice at a single position of the strings. (Note: the choice of assigning '1' and '0' to the two states of each SNP in the strings is arbitrary.)


#####################Counting Optimal Alignments#####################
#####################http://rosalind.info/problems/ctea/#####################

Beware of Alignment Inference

In ‚ÄúEdit Distance Alignment‚Äù, we introduced the concept of an alignment of two genetic strings having differing lengths with respect to edit distance. This provided us with a way of visualizing a specific collection of symbol substitutions, insertions, and deletions that could have taken place on the evolutionary path between the two strings.

However, simply finding one optimal alignment and declaring that it represents a true evolutionary history is a dangerous idea because the actual evolutionary picture may be suboptimal. For that matter, the collection of all optimal alignments may be huge, and the characteristics of these alignments could differ widely.

In order to begin analyzing the collection of optimal alignments for a pair of strings, the first question we will ask is simple: just how many optimal alignments exist?


Problem

Recall from ‚ÄúEdit Distance Alignment‚Äù that if s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ are the augmented strings corresponding to an alignment of strings ss and tt, then the edit alignment score of s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ was given by the Hamming distance dH(s‚Ä≤,t‚Ä≤)dH(s‚Ä≤,t‚Ä≤) (because s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ have the same length and already include gap symbols to denote insertions/deletions).

As a result, we obtain dE(s,t)=mins‚Ä≤,t‚Ä≤dH(s‚Ä≤,t‚Ä≤)dE(s,t)=mins‚Ä≤,t‚Ä≤dH(s‚Ä≤,t‚Ä≤), where the minimum is taken over all alignments of ss and tt. Strings s‚Ä≤s‚Ä≤ and t‚Ä≤t‚Ä≤ achieving this minimum correspond to an optimal alignment with respect to edit alignment score.

Given: Two protein strings ss and tt in FASTA format, each of length at most 1000 aa.

Return: The total number of optimal alignments of ss and tt with respect to edit alignment score, modulo 134,217,727 (2^27-1).



#####################Counting Unrooted Binary Trees#####################
#####################http://rosalind.info/problems/cunr/#####################


Counting Trees

A natural question is to be able to count the total number of distinct unrooted binary trees having nn leaves, where each leaf is labeled by some taxon. Before we can count all these trees, however, we need to have a notion of when two such trees are the same.

Our tool will be the split. Recall from ‚ÄúCreating a Character Table‚Äù that removing any edge from a tree TT separates its leaves into sets SS and ScSc, so that each edge of TT can be labeled by this split S‚à£ScS‚à£Sc. As a result, an unrooted binary tree can be represented uniquely by its collection of splits.


Problem

Two unrooted binary trees T1T1 and T2T2 having the same nn labeled leaves are considered to be equivalent if there is some assignment of labels to the internal nodes of T1T1 and T2T2 so that the adjacency lists of the two trees coincide. As a result, note that T1T1 and T2T2 must have the same splits; conversely, if the two trees do not have the same splits, then they are considered distinct.

Let b(n)b(n) denote the total number of distinct unrooted binary trees having nn labeled leaves.

Given: A positive integer nn (n‚â§1000n‚â§1000).

Return: The value of b(n)b(n) modulo 1,000,000.


#####################Global Alignment with Scoring Matrix#####################
#####################http://rosalind.info/problems/glob/#####################

Generalizing the Alignment Score

The edit alignment score in ‚ÄúEdit Distance Alignment‚Äù counted the total number of edit operations implied by an alignment; we could equivalently think of this scoring function as assigning a cost of 1 to each such operation. Another common scoring function awards matched symbols with 1 and penalizes substituted/inserted/deleted symbols equally by assigning each one a score of 0, so that the maximum score of an alignment becomes the length of a longest common subsequence of ss and tt (see ‚ÄúFinding a Shared Spliced Motif‚Äù). In general, the alignment score is simply a scoring function that assigns costs to edit operations encoded by the alignment.

One natural way of adding complexity to alignment scoring functions is by changing the alignment score based on which symbols are substituted; many methods have been proposed for doing this. Another way to do so is to vary the penalty assigned to the insertion or deletion of symbols.

In general, alignment scores can be either maximized or minimized depending on how scores are established. The general problem of optimizing a particular alignment score is called global alignment.


Problem

To penalize symbol substitutions differently depending on which two symbols are involved in the substitution, we obtain a scoring matrix SS in which Si,jSi,j represents the (negative) score assigned to a substitution of the iith symbol of our alphabet ùíúA with the jjth symbol of ùíúA.

A gap penalty is the component deducted from alignment score due to the presence of a gap. A gap penalty may be a function of the length of the gap; for example, a linear gap penalty is a constant gg such that each inserted or deleted symbol is charged gg; as a result, the cost of a gap of length LL is equal to gLgL.

Given: Two protein strings ss and tt in FASTA format (each of length at most 1000 aa).

Return: The maximum alignment score between ss and tt. Use:

The BLOSUM62 scoring matrix.
Linear gap penalty equal to 5 (i.e., a cost of -5 is assessed for each gap symbol).


#####################Genome Assembly with Perfect Coverage#####################
#####################http://rosalind.info/problems/pcov/#####################


Cyclic Chromosomes

Recall that although chromosomes taken from eukaryotes have a linear structure, many bacterial chromosomes are actually circular. We represented a linear chromosome with a DNA string, so we only need to modify the definition of string to model circular chromosomes.

Perfect coverage is the phenomenon in fragment assembly of having a read (or kk-mer) begin at every possible location in the genome. Unfortunately, perfect coverage is still difficult to achieve, but fragment assembly technology continues to improve by leaps and bounds, and perfect coverage is perhaps not the fantasy it once was.


Problem

A circular string is a string that does not have an initial or terminal element; instead, the string is viewed as a necklace of symbols. We can represent a circular string as a string enclosed in parentheses. For example, consider the circular DNA string (ACGTAC), and note that because the string "wraps around" at the end, this circular string can equally be represented by (CGTACA), (GTACAC), (TACACG), (ACACGT), and (CACGTA). The definitions of substrings and superstrings are easy to generalize to the case of circular strings (keeping in mind that substrings are allowed to wrap around).

Given: A collection of (error-free) DNA kk-mers (k‚â§50k‚â§50) taken from the same strand of a circular chromosome. In this dataset, all kk-mers from this strand of the chromosome are present, and their de Bruijn graph consists of exactly one simple cycle.

Return: A cyclic superstring of minimal length containing the reads (thus corresponding to a candidate cyclic chromosome).


#####################Matching a Spectrum to a Protein#####################
#####################http://rosalind.info/problems/prsm/#####################


Searching the Protein Database

Many proteins have already been identified for a wide variety of organisms. Accordingly, there are a large number of protein databases available, and so the first step after creating a mass spectrum for an unidentified protein is to search through these databases for a known protein with a highly similar spectrum. In this manner, many similar proteins found in different species have been identified, which aids researchers in determining protein function.

In ‚ÄúComparing Spectra with the Spectral Convolution‚Äù, we introduced the spectral convolution and used it to measure the similarity of simplified spectra. In this problem, we would like to extend this idea to find the most similar protein in a database to a spectrum taken from an unknown protein. Our plan is to use the spectral convolution to find the largest possible number of masses that each database protein shares with our candidate protein after shifting, and then select the database protein having the largest such number of shared masses.


Problem

The complete spectrum of a weighted string ss is the multiset S[s] containing the weights of every prefix and suffix of ss.

Given: A positive integer n followed by a collection of n protein strings s1, s2, ..., sn and a multiset R of positive numbers (corresponding to the complete spectrum of some unknown protein string).

Return: The maximum multiplicity of R‚äñS[sk] taken over all strings sk, followed by the string sk for which this maximum multiplicity occurs (you may output any such value if multiple solutions exist).



#####################Quartets##########################################
#####################http://rosalind.info/problems/qrt/#####################

Incomplete Characters

The modern revolution in genome sequencing has produced a huge amount of genetic data for a wide variety of species. One ultimate goal of possessing all this information is to be able to construct complete phylogenies via direct genome analysis.

For example, say that we have a gene shared by a number of taxa. We could create a character based on whether species are known to possess the gene or not, and then use a huge character table to construct our desired phylogeny. However, the present bottleneck with such a method is that it assumes that we already possess complete genome information for all possible species. The race is on to sequence as many species genomes as possible; for instance, the Genome 10K Project aims to sequence 10,000 species genomes over the next decade. Yet for the time being, possessing a complete genomic picture of all Earth's species remains a dream.

As a result of these practical limitations, we need to be able to work with partial characters, which divide taxa into three separate groups: those possessing the character, those not possessing the character, and those for which we do not yet have conclusive information.


Problem

A partial split of a set SS of n taxa models a partial character and is denoted by A‚à£BA‚à£B, where AA and BB are still the two disjoint subsets of taxa divided by the character. Unlike in the case of splits, we do not necessarily require that A‚à™B=SA‚à™B=S; (A‚à™B)c(A‚à™B)c corresponds to those taxa for which we lack conclusive evidence regarding the character.

We can assemble a collection of partial characters into a generalized partial character table C in which the symbol xx is placed in Ci,j if we do not have conclusive evidence regarding the jth taxon with respect to the ith partial character.

A quartet is a partial split A‚à£BA‚à£B in which both AA and BB contain precisely two elements. For the sake of simplicity, we often will consider quartets instead of partial characters. We say that a quartet A‚à£BA‚à£B is inferred from a partial split C‚à£DC‚à£D if A‚äÜCA‚äÜC and B‚äÜDB‚äÜD (or equivalently A‚äÜDA‚äÜD and B‚äÜCB‚äÜC). For example, {1,3}‚à£{2,4} and {3,5}‚à£{2,4} can be inferred from {1,3,5}‚à£{2,4}.

Given: A partial character table C.

Return: The collection of all quartets that can be inferred from the splits corresponding to the underlying characters of C.


#####################Using the Spectrum Graph to Infer Peptides#####################
#####################http://rosalind.info/problems/sgra/#####################

Getting Real with Spectra

In ‚ÄúInferring Peptide from Full Spectrum‚Äù, we considered an idealized version of the simplified spectrum in which every cut through a given peptide was produced, so that the spectrum possessed all possible b-ions and y-ions cutting the peptide. In reality, not every cut will be produced in a spectrum, which may also contain errors. As a result, it is difficult or impossible to recover an entire peptide from a single spectrum.

In the more practical case of a mass spectrum, where intensity is plotted against ions' mass-charge ratios, inferring the protein is also greatly complicated by the presence of erratic peaks in the spectrum.


Problem

For a weighted alphabet ùíúA and a collection L of positive real numbers, the spectrum graph of L is a digraph constructed in the following way. First, create a node for every real number in LL. Then, connect a pair of nodes with a directed edge (u,v) if v>u and v‚àíu is equal to the weight of a single symbol in ùíúA. We may then label the edge with this symbol.

In this problem, we say that a weighted string s=s1s2‚ãØsn matches L if there is some increasing sequence of positive real numbers (w1,w2,‚Ä¶,wn+1)(w1,w2,‚Ä¶,wn+1) in LL such that w(s1)=w2‚àíw1, w(s2)=w3‚àíw2, ..., and w(sn)=wn+1‚àíwn.

Given: A list L (of length at most 100) containing positive real numbers.

Return: The longest protein string that matches the spectrum graph of L (if multiple solutions exist, you may output any one of them). Consult the monoisotopic mass table.

#####################
#####################